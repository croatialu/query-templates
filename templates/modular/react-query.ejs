<%
/**
 * based @tanstack/vue-query
 * */
const { modelTypes, utils, config } = it
const { _, pascalCase } = utils
const combinedArr = it.routes.combined
const dataContracts = _.map(modelTypes, "name");

const isAxiosHttpClient = config.httpClientType === config.constants.HTTP_CLIENT.AXIOS

const QUERY_TYPE = 'react'

const createResponseType = (route) => {
  return `${isAxiosHttpClient ? 'AxiosResponse' : 'HttpResponse'}<${route.response.type}, ${route.response.errorType}>`
}

function parseRouteArgs(route){
  const { id, namespace: routeNamespace, routeName, request, response, specificArgNameResolver  } = route

  const { parameters, path, method, payload, query, formData, security, requestParams } = request;
  const { type, errorType, contentTypes } = response;
  const { HTTP_CLIENT, RESERVED_REQ_PARAMS_ARG_NAMES } = config.constants;

  const queryName = (query && query.name) || "query";
  const pathParams = _.values(parameters);
  const pathParamsNames = _.map(pathParams, "name");

  const requestConfigParam = {
      name: specificArgNameResolver.resolve(RESERVED_REQ_PARAMS_ARG_NAMES),
      optional: true,
      type: "RequestParams",
      defaultValue: "{}",
  }

  const rawWrapperArgs = config.extractRequestParams ?
    _.compact([
        requestParams && {
          name: pathParams.length ? `{ ${_.join(pathParamsNames, ", ")}, ...${queryName} }` : queryName,
          optional: false,
          type: utils.getInlineParseContent(requestParams),
        },
        ...(!requestParams ? pathParams : []),
        payload,
        requestConfigParam,
    ]) :
    _.compact([
        ...pathParams,
        query,
        payload,
        requestConfigParam,
    ])

  const baseArgs = _.sortBy(rawWrapperArgs, [o => o.optional])


  const queryParamsValueTmplStr = `{ ${baseArgs.map(v => v.name).join(', ')} }`
  const queryParamsDestructuringTmplStr = `{ ${baseArgs.map(({ name, defaultValue,  }) => `${name}${defaultValue ? ` = ${defaultValue}` : ''}`).join(', ')} }`

  if(QUERY_TYPE === 'vue') {


    return {
      baseArgs,

      queryParamsTypeTmplStr: `{ ${baseArgs.map(({ name, optional, type }) => `${name}${optional ? '?' : ''}: ${type}`).join(', ')} }`,
      queryParamsValueTmplStr,
      queryParamsDestructuringTmplStr,

      requestParamsValueTmplStr: `${baseArgs.map(v => v.name).join(', ')}`,

    }
  }

  return {
    baseArgs,

    queryParamsTypeTmplStr: `{ ${baseArgs.map(({ name, optional, type }) => `${name}${optional ? '?' : ''}: ${type}`).join(', ')} }`,
    queryParamsValueTmplStr,
    queryParamsDestructuringTmplStr,
    requestParamsValueTmplStr: `${baseArgs.map(v => `${v.name}`).join(', ')}`,
  }
}

const createQueryKeyTmplStr = (namespace, request, requestArgNames) => {
  return `[${[
      '"swagger-typescript-api"', 
      `"${namespace}"`,
      `"${request.method}"`, 
      `"${request.path}"`, 
      ...requestArgNames
    ].join(', ')}]`
}

%>
import { useQuery, UseQueryResult, useQueryClient, UseQueryOptions, MutationOptions, useMutation, UseMutationResult } from '@tanstack/react-query'
<% if (isAxiosHttpClient) { %> import type { AxiosRequestConfig, AxiosResponse } from "axios"; <% } %>

import { HttpClient, RequestParams, ContentType, HttpResponse } from "./<%~ config.fileNames.httpClient %>";

<% for( const combined of combinedArr) {%>
  import { <%= utils.pascalCase(combined.moduleName) %> } from './<%= utils.pascalCase(combined.moduleName) %>'

  <% } %>

<% if (dataContracts.length) { %>
  import { <%~ dataContracts.join(", ") %> } from "./<%~ config.fileNames.dataContracts %>"
  <% } %>

/**
  <%= it.apiConfig.info.title %>

  <%= it.apiConfig.info.version %>

  <%= it.apiConfig.info.description %>

*/

type CustomQueryOptions<T, E> = Omit<UseQueryOptions< <%~ isAxiosHttpClient ? 'AxiosResponse' : 'HttpResponse'%><T, E> >, 'queryKey' | 'queryFn'>
type CustomMutationOptions<T, E, V> = Omit<MutationOptions< <%~ isAxiosHttpClient ? 'AxiosResponse' : 'HttpResponse'%><T, E>, E, V>, 'mutationFn'>

<% for (const combined of combinedArr) { %>
  <% 
    const moduleName = combined.moduleName
    const moduleClassName = utils.pascalCase(moduleName)
    const moduleCreatorName = `create${moduleClassName}Query`
    const queryUpdateName = `use${moduleClassName}QueryUpdate`
    
  %>
  export const <%= moduleCreatorName %> = (api: <%= moduleClassName %>) => {

    <% 
      const routes = combined.routes.map(item =>  {
        const { routeName, request } = item

        const isQuery = request.method === 'get'

        const queryFnName = `use${utils.pascalCase(routeName.usage)}`
        const mutationFnName = `use${utils.pascalCase(routeName.usage)}Mutation`
        const createQueryKeyFnName = `create${utils.pascalCase(routeName.usage)}QueryKey`




        return {
          route: item,
          queryFnName,
          mutationFnName,
          createQueryKeyFnName,
          isQuery
        }
      })

    
    %>

      <% for (const { route, queryFnName, mutationFnName, createQueryKeyFnName  } of routes) { %>
        <% 
        const { routeName, request, response  } = route
        const { 
          baseArgs,

          queryParamsTypeTmplStr,
          queryParamsValueTmplStr,
          queryParamsDestructuringTmplStr,
          requestParamsValueTmplStr,
        } = parseRouteArgs(route)
        const routeDocs = includeFile("@base/route-docs", { config, route, utils });  
        
        const queryOptionTypeName = `CustomQueryOptions<${response.type}, ${response.errorType}>`

        const mutationOptionTypeName = `CustomMutationOptions<${response.type}, ${response.errorType}, ${queryParamsTypeTmplStr}>`

        const queryKeyValueTmplStr = createQueryKeyTmplStr(moduleName, request, baseArgs.map(v => v.name))
        const responseType = createResponseType(route)
        %>

        /**
        <%~ routeDocs.description %>
        
          *<% /* Here you can add some other JSDoc tags */ %>
        
        <%~ routeDocs.lines %>
        
          */
        <% if(request.method === 'get') { %>
              function <%= queryFnName %>(
                  apiParams: <%~ queryParamsTypeTmplStr %>,
                  queryOptions: <%~ queryOptionTypeName %> = {}     
              ) {
                  const <%~ queryParamsDestructuringTmplStr %> = apiParams
                  return useQuery({
                      ...queryOptions,
                      queryKey: <%= createQueryKeyFnName %>(<%~ queryParamsValueTmplStr %>),
                      queryFn: (() => {
                          // @ts-ignore
                          return api.<%= routeName.usage %>(<%~ requestParamsValueTmplStr %>)
                      }) as any
                  }) as unknown as UseQueryResult<<%~ responseType %>, <%~ response.errorType %>>
              }
              function <%= createQueryKeyFnName %>(apiParams: <%~ queryParamsTypeTmplStr %> ) {
                  const <%~ queryParamsDestructuringTmplStr %> = apiParams
                  return <%~ queryKeyValueTmplStr %> as const
              }
            <% } else { %>
              function <%= mutationFnName %>(
                mutationOptions: <%~ mutationOptionTypeName %> = {}     
              ) {
                return useMutation({
                    ...mutationOptions,
                    mutationFn: ((apiParams: <%~ queryParamsTypeTmplStr %>) => {
                        const <%~ queryParamsDestructuringTmplStr %> = apiParams

                        // @ts-ignore
                        return api.<%= routeName.usage %>(<%~ requestParamsValueTmplStr %>)
                    }) as any
                }) as unknown as UseMutationResult<<%~ responseType %>, <%~ response.errorType %>, <%~ queryParamsTypeTmplStr %>, any>
              }
            <% } %>
    <% } %>

    return {
      <% for (const { route, queryFnName, mutationFnName, createQueryKeyFnName, isQuery } of routes) { %>
        <%= isQuery ? [queryFnName, createQueryKeyFnName].join(', ') : mutationFnName %>,
      <% } %>
    }
  }
  
  export const <%= queryUpdateName %> = () => {
    const queryClient = useQueryClient()
  
    <% for (const route of combined.routes) { %>
      <% 
      const { request } = route
      const { baseArgs } = parseRouteArgs(route)
      const responseType = createResponseType(route)
      const queryKeyTypeTmplStr = createQueryKeyTmplStr(moduleName, request, baseArgs.map(v => v.type))

      %>
      function setQueryData(
        queryKey: readonly <%~ queryKeyTypeTmplStr %>,
  Â      updater: (data: <%~ responseType %>) => <%~ responseType %>,
        ): Promise<<%~ responseType %>>
    <% } %>
    function setQueryData(queryKey: any, updater: any)  {
      return queryClient.setQueryData(queryKey, updater)
    }
    
    return setQueryData
  }
  
  <% } %>